<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CarFlix Navigation</title>
  <link href="https://unpkg.com/maplibre-gl@3.3.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.3.1/dist/maplibre-gl.js"></script>
  <style>
    body, html {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      background: #111;
      color: white;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      background: #000;
      padding: 14px 20px;
      font-size: 1.3rem;
      font-weight: bold;
      color: #4cd964;
      text-align: center;
    }
    #content {
      flex: 1;
      display: flex;
      overflow: hidden;
    }
    #sidebar {
      width: 260px;
      background: #1a1a1a;
      padding: 12px;
      border-right: 2px solid #333;
      overflow-y: auto;
    }
    #sidebar input, #sidebar button {
      width: 100%;
      padding: 10px;
      margin-bottom: 8px;
      border: none;
      border-radius: 10px;
      font-size: 1rem;
    }
    #sidebar input {
      background: #333;
      color: white;
    }
    #sidebar button {
      background: #4cd964;
      color: black;
      font-weight: bold;
      cursor: pointer;
    }
    #info {
      color: #4cd964;
      font-size: 14px;
      margin-top: 8px;
    }
    #directions {
      font-size: 13px;
      margin-top: 10px;
      line-height: 1.4;
    }
    #map {
      flex: 1;
    }
  </style>
</head>
<body>
  <header>üöò CarFlix Navigation (Smart Voice + Follow)</header>
  <div id="content">
    <div id="sidebar">
      <input id="from" placeholder="From..." />
      <input id="to" placeholder="To..." />
      <button onclick="startRoute()">üß≠ Start</button>
      <button onclick="useCurrentLocation()">üìç Go From Current Location</button>
      <button onclick="simulate()">‚ñ∂Ô∏è Play</button>
      <button onclick="pauseRoute()">‚è∏Ô∏è Pause</button>
      <button onclick="stopRoute()">‚èπÔ∏è Stop</button>
      <div id="info">Distance/ETA will appear here</div>
      <div id="directions"></div>
    </div>
    <div id="map"></div>
  </div>

  <script>
    const maptilerKey = "ugTZPCyMGWoZWo0Nk5Mf";
    const orsKey = "5b3ce3597851110001cf624851ef43534fc04e808410c180a68b1a24";
    let coordinates = [], marker, animIndex = 0, animation, isPaused = false;
    let totalDistance = 0, remainingDistance = 0, steps = [], lastLngLat = null;

    const map = new maplibregl.Map({
      container: "map",
      style: `https://api.maptiler.com/maps/streets/style.json?key=${maptilerKey}`,
      center: [77.2090, 28.6139],
      zoom: 6,
      pitch: 60,
      bearing: 0
    });

    map.addControl(new maplibregl.NavigationControl());

    function geocode(query) {
      return fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`)
        .then(res => res.json())
        .then(data => {
          if (!data.length) throw new Error("Location not found");
          return [parseFloat(data[0].lon), parseFloat(data[0].lat)];
        });
    }

    async function startRoute(fromCoords = null) {
      clearInterval(animation);
      animIndex = 0;

      const fromInput = document.getElementById("from").value;
      const toInput = document.getElementById("to").value;
      if (!fromCoords && !fromInput) return alert("Enter a start location or use GPS");
      if (!toInput) return alert("Enter a destination");

      const from = fromCoords || await geocode(fromInput);
      const to = await geocode(toInput);

      const res = await fetch("https://api.openrouteservice.org/v2/directions/driving-car/geojson", {
        method: "POST",
        headers: {
          "Authorization": orsKey,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ coordinates: [from, to] })
      });

      const geojson = await res.json();
      coordinates = geojson.features[0].geometry.coordinates;
      steps = geojson.features[0].properties.segments[0].steps;
      totalDistance = geojson.features[0].properties.summary.distance;
      remainingDistance = totalDistance;

      document.getElementById("info").innerText = `Distance: ${(totalDistance / 1000).toFixed(2)} km`;

      document.getElementById("directions").innerHTML =
        steps.map(s => `<p>‚Ä¢ ${s.instruction}</p>`).join("");

      if (map.getSource("route")) map.removeLayer("route"), map.removeSource("route");
      map.addSource("route", { type: "geojson", data: geojson });
      map.addLayer({
        id: "route",
        type: "line",
        source: "route",
        paint: { "line-color": "#4cd964", "line-width": 6 }
      });

      if (marker) marker.remove();
      marker = new maplibregl.Marker({ color: "red", rotationAlignment: "map" })
        .setLngLat(from)
        .addTo(map);

      map.flyTo({ center: from, zoom: 17, pitch: 60 });
    }

    function useCurrentLocation() {
      navigator.geolocation.getCurrentPosition(pos => {
        const current = [pos.coords.longitude, pos.coords.latitude];
        startRoute(current);
      }, () => alert("Unable to access GPS location"));
    }

    function simulate() {
      if (!coordinates.length || !marker) return alert("Start the route first.");
      clearInterval(animation);
      isPaused = false;

      animation = setInterval(() => {
        if (isPaused || animIndex >= coordinates.length - 1) {
          clearInterval(animation);
          speak("You have reached your destination.");
          return;
        }

        const [lng1, lat1] = coordinates[animIndex];
        const [lng2, lat2] = coordinates[animIndex + 1] || coordinates[animIndex];
        const bearing = getBearing(lat1, lng1, lat2, lng2);
        const stepDist = calcDistance(lat1, lng1, lat2, lat2);
        remainingDistance -= stepDist;

        marker.setLngLat([lng1, lat1]);
        marker.setRotation(bearing);

        // Only move map if movement > 5m
        const moved = !lastLngLat || calcDistance(lat1, lng1, lastLngLat[1], lastLngLat[0]) > 5;
        if (moved) {
          map.easeTo({ center: [lng1, lat1], zoom: 17, bearing, pitch: 60, duration: 300 });
          lastLngLat = [lng1, lat1];
        }

        document.getElementById("info").innerText = `Remaining: ${(remainingDistance / 1000).toFixed(2)} km`;

        // Voice speak step
        if (animIndex < steps.length && steps[animIndex]?.instruction) {
          speak(steps[animIndex].instruction);
        }

        animIndex++;
      }, 500);
    }

    function pauseRoute() {
      isPaused = true;
      clearInterval(animation);
    }

    function stopRoute() {
      clearInterval(animation);
      isPaused = false;
      animIndex = 0;
      remainingDistance = totalDistance;
      if (marker && coordinates.length > 0) {
        marker.setLngLat(coordinates[0]);
        map.flyTo({ center: coordinates[0], zoom: 16, pitch: 45 });
      }
      document.getElementById("info").innerText = `Distance: ${(totalDistance / 1000).toFixed(2)} km`;
    }

    function getBearing(lat1, lon1, lat2, lon2) {
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const y = Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180);
      const x = Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
                Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon);
      return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    }

    function calcDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const œÜ1 = lat1 * Math.PI / 180;
      const œÜ2 = lat2 * Math.PI / 180;
      const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
      const ŒîŒª = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(ŒîœÜ / 2) ** 2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function speak(text) {
      const msg = new SpeechSynthesisUtterance(text);
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(msg);
    }
  </script>
</body>
</html>
